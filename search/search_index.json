{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"examples/","title":"Arduino Examples","text":"<p>Let's take an in-depth look at most of the examples included in the SparkFun Simultaneous RFID Reader Arduino Library.</p>"},{"location":"examples/#uart-switch-position-software-serial","title":"UART Switch Position &amp; Software Serial","text":"<p>Make sure the Serial Selection Switch is in the \"SER\" position when using this library. All of the examples in this Arduino library use the Software Serial Library so if you are not using the SparkFun RedBoard IoT and following the assembly instructions in the Hardware Assembly section, make sure to connect the RX/TX pins on the SER header to compatible pins on your chosen development board. Note, this library </p>"},{"location":"examples/#code-to-note","title":"Code to Note","text":"<p>The latest version of the Simultaneous RFID Reader Library has a couple of settings to take note of and adjust accordingly depending on your hardware and setup.</p>"},{"location":"examples/#serial-selection-software-vs-hardware","title":"Serial Selection (Software vs Hardware)","text":"<p>If you're using a development board that supports Software Serial, uncomment the following lines and adjust the pins for RX/TX if necessary:</p> <pre><code>#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n</code></pre> <p>The next option selects which type of serial is used. The code lists a couple of examples for both software serial and hardware so adjust the definition as needed. For example, if you're using a software serial library, define this as <code>softserial</code>. If you're using a hardware serial port on your development board, select the serial port (eg. Serial1) as shown below: </p> <pre><code>// #define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n#define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n</code></pre>"},{"location":"examples/#baud-rate-selection","title":"Baud Rate Selection","text":"<p>Next, you'll want to define the baud rate for <code>rfidBaud</code>. We recommend using the settings shown below with 38400 when using software serial and 115200 when using hardware serial:</p> <pre><code>// #define rfidBaud 38400\n#define rfidBaud 115200\n</code></pre>"},{"location":"examples/#module-selection","title":"Module Selection","text":"<p>Since this library supports both the M6E Nano and M7E Hecto, you'll need to define which module you are using. Adjust or comment/uncomment the <code>moduleType</code> definition to set it to the correct module:</p> <pre><code>// #define moduleType ThingMagic_M6E_NANO\n#define moduleType ThingMagic_M7E_HECTO\n</code></pre>"},{"location":"examples/#example-1-constant-read","title":"Example 1 - Constant Read","text":"<p>The first example sets the M7E to constantly scan and report any tags it sees in the vicinity. Open the example by navigating to File &gt; Examples &gt; SparkFun Simultaneous RFID Reader Library &gt; Example 1 Constant Read. Select your Board and Port and click the \"Upload\" button. Once the code finishes uploading, open the serial monitor with the baud set to 115200. </p> Example 1 - Constant Read <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Constantly reads and outputs any tags heard\n\n  If using the Simultaneous RFID Tag Reader (SRTR) shield, make sure the serial slide\n  switch is in the 'SW-UART' position\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n  while (!Serial); //Wait for the serial port to come online\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(F(\"Module failed to respond. Please check wiring.\"));\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may caues USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n  Serial.println(F(\"Press a key to begin scanning for tags.\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  rfidModule.startReading(); //Begin scanning for tags\n}\n\nvoid loop()\n{\n  if (rfidModule.check() == true) //Check to see if any new data has come in from module\n  {\n    byte responseType = rfidModule.parseResponse(); //Break response into tag ID, RSSI, frequency, and timestamp\n\n    if (responseType == RESPONSE_IS_KEEPALIVE)\n    {\n      Serial.println(F(\"Scanning\"));\n    }\n    else if (responseType == RESPONSE_IS_TAGFOUND)\n    {\n      //If we have a full record we can pull out the fun bits\n      int rssi = rfidModule.getTagRSSI(); //Get the RSSI for this tag read\n\n      long freq = rfidModule.getTagFreq(); //Get the frequency this tag was detected at\n\n      long timeStamp = rfidModule.getTagTimestamp(); //Get the time this was read, (ms) since last keep-alive message\n\n      byte tagEPCBytes = rfidModule.getTagEPCBytes(); //Get the number of bytes of EPC from response\n\n      Serial.print(F(\" rssi[\"));\n      Serial.print(rssi);\n      Serial.print(F(\"]\"));\n\n      Serial.print(F(\" freq[\"));\n      Serial.print(freq);\n      Serial.print(F(\"]\"));\n\n      Serial.print(F(\" time[\"));\n      Serial.print(timeStamp);\n      Serial.print(F(\"]\"));\n\n      //Print EPC bytes, this is a subsection of bytes from the response/msg array\n      Serial.print(F(\" epc[\"));\n      for (byte x = 0 ; x &lt; tagEPCBytes ; x++)\n      {\n        if (rfidModule.msg[31 + x] &lt; 0x10) Serial.print(F(\"0\")); //Pretty print\n        Serial.print(rfidModule.msg[31 + x], HEX);\n        Serial.print(F(\" \"));\n      }\n      Serial.print(F(\"]\"));\n\n      Serial.println();\n    }\n    else if (responseType == ERROR_CORRUPT_RESPONSE)\n    {\n      Serial.println(\"Bad CRC\");\n    }\n    else if (responseType == RESPONSE_IS_HIGHRETURNLOSS)\n    {\n      Serial.println(\"High return loss, check antenna!\");\n    }\n    else\n    {\n      //Unknown response\n      Serial.println(\"Unknown error\");\n    }\n  }\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p>The code attempts to set up the module with the defined baud rate and if that fails, it prints \"Module failed to respond. Please check wiring\" If you see this prompt, double-check your connections to your development board and retry. On successful module startup and setup, the code prints \"Press a key to begin scanning for tags.\" Send any key message and the M7E will begin to scan for any tags in range and print out their EPC as the screenshot below shows:</p> <p></p>"},{"location":"examples/#example-2-read-epc","title":"Example 2 - Read EPC","text":"<p>The second example demonstrates how to perform a single-shot read of one tag in the reader's range and print out the EPC value over serial. This example uses the <code>.readTagEPC()</code> function to pass it an array of bytes (in almost all cases EPCs are 12 bytes), the size of the array (12), and the amount of time to scan before giving up (500ms is default). This returns RESPONSE_SUCCESS when the M7E detects a tag and stores the EPC in the array given.</p> Example 2 - Read EPC <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Single shot read - Ask the reader to tell us what tags it currently sees. And it beeps!\n\n  If using the Simultaneous RFID Tag Reader (SRTR) shield, make sure the serial slide\n  switch is in the 'SW-UART' position.\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\n#define BUZZER1 9\n//#define BUZZER1 0 //For testing quietly\n#define BUZZER2 10\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  pinMode(BUZZER1, OUTPUT);\n  pinMode(BUZZER2, OUTPUT);\n\n  digitalWrite(BUZZER2, LOW); //Pull half the buzzer to ground and drive the other half.\n\n  while (!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Press a key to scan for a tag\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  byte myEPC[12]; //Most EPCs are 12 bytes\n  byte myEPClength;\n  byte responseType = 0;\n\n  while (responseType != RESPONSE_SUCCESS)//RESPONSE_IS_TAGFOUND)\n  {\n    myEPClength = sizeof(myEPC); //Length of EPC is modified each time .readTagEPC is called\n\n    responseType = rfidModule.readTagEPC(myEPC, myEPClength, 500); //Scan for a new tag up to 500ms\n    Serial.println(F(\"Searching for tag\"));\n  }\n\n  //Beep! Piano keys to frequencies: http://www.sengpielaudio.com/KeyboardAndFrequencies.gif\n  tone(BUZZER1, 2093, 150); //C\n  delay(150);\n  tone(BUZZER1, 2349, 150); //D\n  delay(150);\n  tone(BUZZER1, 2637, 150); //E\n  delay(150);\n\n  //Print EPC\n  Serial.print(F(\" epc[\"));\n  for (byte x = 0 ; x &lt; myEPClength ; x++)\n  {\n    if (myEPC[x] &lt; 0x10) Serial.print(F(\"0\"));\n    Serial.print(myEPC[x], HEX);\n    Serial.print(F(\" \"));\n  }\n  Serial.println(F(\"]\"));\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p></p> <p>Note, this example also includes definitions and code to set up and use the buzzer found on the Simultaneous RFID Reader - M6E Nano which is not present on the Simultaneous RFID Reader - M7E though users can wire a buzzer like this for an audio feedback when a tag is scanned.</p>"},{"location":"examples/#example-3-write-epc","title":"Example 3 - Write EPC","text":"<p>Example 3 shows how to write a character string and store it as a custom EPC value. This is a great way to keep track of which tag is which by setting the EPC to something like <code>WRENCH</code> or <code>PILL#317</code>. Note, EPCs can only be written in an even number of bytes like the example sets it to:</p> Example 3 - Write EPC <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Write a new EPC (Electronic Product Code) to a tag\n  This is a good way to assign your own, easy to read ID to a tag.\n  Most tags have 12 bytes available for EPC\n\n  EPC is good for things like UPC (this is a gallon of milk)\n  User data is a good place to write things like the milk's best by date\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while (!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n  rfidModule.setWritePower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Write TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Get all tags out of the area. Press a key to write EPC to first detected tag.\"));\n  if (Serial.available()) Serial.read(); //Clear any chars in the incoming buffer (like a newline char)\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  //\"Hello\" Does not work. \"Hell\" will be recorded. You can only write even number of bytes\n  //char stringEPC[] = \"Hello!\"; //You can only write even number of bytes\n  //byte responseType = nano.writeTagEPC(stringEPC, sizeof(stringEPC) - 1); //The -1 shaves off the \\0 found at the end of string\n\n  char hexEPC[] = {0xFF, 0x2D, 0x03, 0x54}; //You can only write even number of bytes\n  byte responseType = rfidModule.writeTagEPC(hexEPC, sizeof(hexEPC));\n\n  if (responseType == RESPONSE_SUCCESS)\n    Serial.println(\"New EPC Written!\");\n  else\n    Serial.println(\"Failed write\");\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p><pre><code>char stringEPC[] = \"Hello!\"; //You can only write even number of bytes\nbyte responseType = nano.writeTagEPC(stringEPC, sizeof(stringEPC) - 1); //The -1 shaves off the \\0 found at the end of string\n</code></pre> This example also introduces a new function <code>setWritePower()</code>. This sets the power level when writing to a tag similar to <code>setReadPower</code> so it can be boosted up to the same values as read power.</p> <pre><code>nano.setWritePower(500); //5.00 dBm. Higher values may cause USB port to brown out\n//Max Write TX Power is 27.00 dBm and may cause temperature-limit throttling\n</code></pre>"},{"location":"examples/#examples-4-5-readwrite-user-data","title":"Examples 4 &amp; 5 - Read/Write User Data","text":"<p>Example 4 shows how to detect and read a tag's available user memory. Not all UHF RFID tags have user memory and may not be configurable.</p> Example 4 - Read User Data <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Read the user writeable data from a detected tag\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while (!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Press a key to read user data\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  //Read the data from the tag\n  byte responseType;\n  byte myData[64];\n  byte myDataLength = sizeof(myData); //Tell readUserData to read up to 64 bytes\n\n  responseType = rfidModule.readUserData(myData, myDataLength); //readUserData will modify myDataLength to the actual # of bytes read\n\n  if (responseType == RESPONSE_SUCCESS)\n  {\n    //Print User Data\n    Serial.print(F(\"Size [\"));\n    Serial.print(myDataLength);\n    Serial.print(F(\"] User data[\"));\n    for (byte x = 0 ; x &lt; myDataLength ; x++)\n    {\n      if (myData[x] &lt; 0x10) Serial.print(F(\"0\"));\n      Serial.print(myData[x], HEX);\n      Serial.print(F(\" \"));\n    }\n    Serial.println(F(\"]\"));\n  }\n  else\n    Serial.println(F(\"Error reading tag data\"));\n\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p>Example 5 demonstrates how to edit a tag's user data through the <code>.writeUserData()</code> function. This function lets you pass an array of characters to the function and records it to the first tag detected by the reader. </p> Example 5 - Write User Data <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Write new data to the user data area\n  Some tags have 64, 16 4, or 0 bytes of user data available for writing.\n\n  If you write more bytes than is available (10 bytes and only 4 available) module will simply timeout.\n\n  EPC is good for things like UPC (this is a gallon of milk)\n  User data is a good place to write things like the milk's best by date\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while (!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may caues USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n  rfidModule.setWritePower(900); //9.00 dBm. Higher values may caues USB port to brown out\n  //Max Write TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println();\n  Serial.println(F(\"Get all tags out of the area. Press a key to write DATA to first detected tag.\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  //\"Hello\" is recorded as \"Hell\". You can only write even number of bytes\n  uint8_t testData[] = \"ACBD\"; //You can only write even number of bytes\n  byte responseType = rfidModule.writeUserData(testData, sizeof(testData) - 1); //The -1 shaves off the \\0 found at the end of string\n\n  if (responseType == RESPONSE_SUCCESS)\n    Serial.println(\"New Data Written!\");\n  else\n  {\n    Serial.println();\n    Serial.println(\"Failed write\");\n    Serial.println(\"Did you write more data than the tag has memory?\");\n    Serial.println(\"Is the tag locked?\");\n  }\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <pre><code>char testData[] = \"ACBD\"; //Must be even number of bytes. \"Hello\" is recorded as \"Hell\".\nbyte responseType = nano.writeUserData(testData, sizeof(testData) - 1); //The -1 shaves off the \\0 found at the end of string\n</code></pre> <p></p> <p>A few bytes of editable memory may not sound like a lot be remember these are passive tags - no batteries required! You can query a tag for the user's dietary restrictions. Or you could adjust the lighting depending on who walked in the room. Or you could set the time at which a medication must be taken. Perhaps a prosthetic leg goes into a more aggressive mode when basketball shorts are worn. </p>"},{"location":"examples/#examples-6-7-8-passwords","title":"Examples 6, 7, 8 - Passwords","text":"<p>The next three examples all deal with passwords to lock a tag with an Access Password or disable a tag with a Kill Password. </p> <p>Example 6 - Read Passwords displays the Access and Kill passwords for a tag detected by the reader. The Access password allows a user to lock a tag, preventing modification of various parts of the memory (EPC, User, etc). The Kill password is needed to disable a tag. Both passwords are <code>0x00000000</code> by default. </p> Example 6 - Read Passwords <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Don't get too excited, this only reads the passwords if they are unlocked.\n\n  There are two passwords associated with any given tag: the Kill PW and the Acess PW\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while (!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Get all tags out of the area. Press a key to read PWs from first detected tag.\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  byte response;\n  byte myPW[4];\n  byte pwLength = sizeof(myPW);\n\n  //Read Kill password\n  response = rfidModule.readKillPW(myPW, pwLength);\n  if (response == RESPONSE_SUCCESS)\n  {\n    Serial.println(\"PW read!\");\n    Serial.print(\"KillPW: [\");\n    for(byte x = 0 ; x &lt; pwLength ; x++)\n    {\n      if(myPW[x] &lt; 0x10) Serial.print(\"0\");\n      Serial.print(myPW[x], HEX);\n      Serial.print(\" \");\n    }\n    Serial.println(\"]\");\n  }\n  else\n    Serial.println(\"Failed read\");\n\n\n  //Read Access PW\n  pwLength = sizeof(myPW); //Reset this variable. May have been changed above.\n  response = rfidModule.readAccessPW(myPW, pwLength);\n  if (response == RESPONSE_SUCCESS)\n  {\n    Serial.println(\"PW read!\");\n    Serial.print(\"AccessPW: [\");\n    for(byte x = 0 ; x &lt; pwLength ; x++)\n    {\n      if(myPW[x] &lt; 0x10) Serial.print(\"0\");\n      Serial.print(myPW[x], HEX);\n      Serial.print(\" \");\n    }\n    Serial.println(\"]\");\n  }\n  else\n    Serial.println(\"Failed read\");\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p></p> <p>Example 7 - Write Passwords shows you how to write new passwords for both Access and Kill. </p> Example 7 - Write Passwords <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Obviously, be careful because this premanently and irrevocably destroys a tag.\n\n  This shows how to send the right command (with password) to disable a tag.\n\n  Arduino pin 2 to Nano TX\n  Arduino pin 3 to Nano RX\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while(!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while(1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n  rfidModule.setWritePower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Write TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Get all tags out of the area. Press a key to write PWs to first detected tag.\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  byte myKillPW[] = {0xEE, 0xFF, 0x11, 0x22};\n  byte response = rfidModule.writeKillPW(myKillPW, sizeof(myKillPW));\n\n  if (response == RESPONSE_SUCCESS)\n    Serial.println(\"New Kill PW Written!\");\n  else\n    Serial.println(\"Failed write\");\n\n  byte myAccessPW[] = {0x12, 0x34, 0x56, 0x78};\n  response = rfidModule.writeAccessPW(myAccessPW, sizeof(myAccessPW));\n\n  if (response == RESPONSE_SUCCESS)\n    Serial.println(\"New Access PW Written!\");\n  else\n    Serial.println(\"Failed write\");\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p>These values can be adjusted from the passwords set in the example by changing the following lines for myKillPW and myAccessPW:</p> <pre><code>byte myKillPW[] = {0xEE, 0xFF, 0x11, 0x22};\n\nbyte myAccessPW[] = {0x12, 0x34, 0x56, 0x78};\n</code></pre> <p></p> <p>After running Example 7, re-run Example 6 to see the updated passwords and ensure they are correct. It may seem odd that you can view the passwords. The Gen2 protocol has quite a few methods to lock out various portions of the memory preventing them from being read. Once the Access password is set the ability to read passwords, read user memory, and read portions of the EPC can all be controlled; this is called locking. Currently, locking is not supported in the Arduino library but it is available in the URA and in the Mercury API.</p> <p>Example 8 - Kill Tag is an interesting example. It's pretty rare that you'll need to kill a tag but we find the concept fascinating and wanted to build in support for it.</p> Danger! <p>Note: Killing a tag blows an internal fuse to the IC and makes the tag irreversibly dead.</p> Example 8 - Kill Tag <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  To kill a tag the tag's kill password must be set. When tags are shipped their passwords\n  are set to 0x00000000. See the Write_Passwords example to write access and kill passwords.\n\n  Obviously, be careful because this premanently and irrevocably destroys a tag.\n\n  This shows how to send the right command (with password) to disable a tag.\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while(!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while(1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n  rfidModule.setWritePower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Write TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Get all tags out of the area. Press a key to KILL first detected tag.\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  byte myKillPW[] = {0x1A, 0x2B, 0x3C, 0x4E}; //This must be edited to match your kill password\n//  byte myKillPW[] = {0xEE, 0xFF, 0x11, 0x22};\n\n  byte response = rfidModule.killTag(myKillPW, sizeof(myKillPW));\n\n  if (response == RESPONSE_SUCCESS)\n    Serial.println(\"Tag has been killed!\");\n  else\n  {\n    Serial.println(\"Kill Failed\");\n    Serial.println(\"Did you set the kill PW to something other than 0s?\");\n  }\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p>It is very good to see that the protocol has the kill feature. Killing a tag makes sense after an item has been purchased (gallon of milk) or a process has been completed (dry cleaning has been picked up). By limiting the life-span of a tag you can help protect end user privacy and tracking.</p> <p>The Gen2 protocol is well written and prevents a user from walking into a Wal-Mart and blasting away all the tags that haven't been configured. The default Kill password is all 0s but any tag will ignore the kill command with the password set to 0s. Therefore, you must first write a non-zero kill password (using Example7) then you must issue the kill command using the new password.</p> <p></p> <p>If you're very paranoid about someone else using an UHF RFID reader/writer to reconfigure your tags consider writing new Access and Kill passwords to your tags then use the Universal Reader Assistant to lock the tags.</p>"},{"location":"external_antenna/","title":"Using an External Entenna","text":"<p>The integrated PCB antenna works well over short distances but users who want to get the maximum range for the M7E Hecto should consider using an external antenna. Connecting an external antenna to the Simultaneous RFID Reader - M7E requires some hardware adjustments, minor assembly steps and other considerations regarding the antenna. Let's go over these adjustments and considerations. </p>"},{"location":"external_antenna/#fcc-regulations","title":"FCC Regulations","text":"<p>From section 5.8 of the M7E Hecto User Guide:</p> <p>No additional transmitter-compliance testing is required if the module is operated with the same type of antenna as listed in the FCC filing, as long as it has equal or lower gain than the antenna listed. Equivalent antennas must be of the same general type (e.g. dipole, circularly polarized patch, etc.), and must have similar in-band and out-of-band characteristics (consult specification sheet for cutoff frequencies).</p> <p>The board's PCB trace antenna is a patch antenna with a much lower gain than the list of approved antennas which allows the use of an unmodified board in the field without additional FCC testing.</p> <p>The u.FL connector allows users to connect higher-gain directional antennas. However, there are stipulations as to what external antennas can be used and additional FCC certifications may be required. </p> <p>Info</p> <p>Note: The onboard PCB antenna complies with the FCC regulation.</p> <p>The list below from section 5.7 of the M7E Hecto User Guide outlines antennas ThingMagic has tested and gotten approved by the FCC. You may use a different antenna from the ones in the list but it must be of equal or less gain than an antenna previously authorized under the same FCC ID and must have similar in-band and out-of0band characteristics (consult specification sheet for cut-off frequencies) if used in a product without additional testing.</p> <p></p> List of approved antenas"},{"location":"external_antenna/#attaching-the-external-antenna","title":"Attaching the External Antenna","text":"<p>Switching to the external antenna connection requires changing the position of the antenna (labeled RF) resistor to route the M7E's antenna signal to the u.FL connector on the board.</p> <p>Adjusting from PCB Antenna to u.FL Connection</p> <p>Note:  You do not need an external antenna for basic use of the Simultaneous RFID Reader - M7E but the PCB antenna reads tags reliably at only up to a few inches away at the highest read power and with the PCB antenna positioned away from any solid surfaces. If you want to take advantage of the full range, follow the steps below to modify the board and enable the u.FL connector for an external antenna connection. </p> <p>If you have never worked with surface mount components, we recommend reading through these tutorials:</p> <ul> <li> <p> How to Use a Hot Air Rework Station </p> </li> <li> <p> How to Solder: Through-Hole Soldering - Advanced SMD </p> </li> </ul> <p>Carefully reflow the 0k\u03a9 resistor labeled RF to move it to the u.FL position. You can either use a soldering iron or hot-air rework station to reflow the solder holding the resistor into place. The photo below shows the RF resistor after adjusting it to the u.FL position.</p> <p></p> Take careful note of the position of this resistor in the photo to make sure it is in the correct position. <p>Next, attach the u.FL to the RP-SMA connector cable. Because this connector is fragile we recommend either taping or hot gluing the sheath of the cable to the PCB. This will help prevent damage to the u.FL connector in case the cable gets pulled on.</p> <p></p> <p>To get the best range we recommend attaching an external high-gain antenna to a tripod of some sort. If you only have a desk, that's ok too.</p> <p></p> <p>We used the included hardware with the antenna to attach it to the leg of the tripod. </p> <p></p> <p>Now connect the RP-SMA to RP-TNC cable. And finally, connect the RP-TNC to the external antenna. You can use a different UHF RFID antenna but you will need to have the correct connectors and cables to go from the u.FL connector on the board to the connector on your specific antenna.</p> <p></p> <p>Warning</p> <p>Don't Forget! Ensure that personnel do not stand in the radiation beam of the antenna unless they are more than 21cm away from the face of the antenna (to adhere to FCC limits for long-term exposure). Refer to the M7E Hecto design guide for more information.</p>"},{"location":"hard_copy/","title":"Hard copy","text":"<p>Need to download or print our hookup guide?</p> <ul> <li>Print  (Single-Page View)<ul> <li>To save as a <code>*.pdf</code> file, select the Printer or Destination labeled Save as PDF. (Instructions will vary based on the browser)</li> </ul> </li> </ul>"},{"location":"hardware_assembly/","title":"Basic Assembly","text":"<p>In this section we'll cover the two ways to set up the Simultaneous RFID Reader - M7E over both USB-C and connected to a microcontroller for use with the SparkFun Simultaneous RFID Reader Arduino Library. </p>"},{"location":"hardware_assembly/#communicating-via-usb-c-serial","title":"Communicating via USB-C Serial","text":"<p>The fastest and easiest way to start using the board is through the USB-C connector. Simply plug the board into a computer with a USB-C cable and open up the Universal Reader Assistant.</p> <p></p> <p>Reminder, many computer USB ports can only supply ~500mA @5V which limits the power level settings to roughly 20dBm and lower. Running the M7E at higher power levels may require a dedicated power supply.</p>"},{"location":"hardware_assembly/#communicating-via-serial-pth-header","title":"Communicating via Serial PTH Header","text":"<p>Users who prefer to communicate with the RFID reader using the Serial PTH header should solder either wires or header pins to connect them to a 3.3V microcontroller (you can also use this to connect to a USB UART board like the Serial Basic. If you are not familiar with through-hole soldering or would like a refresher, take a read through this tutorial.</p> <p></p> <p>We'll demonstrate soldering male headers to the board and use jumper wires to connect the RFID Reader to the SparkFun RedBoard Artemis for use with the SparkFun Simultaneous RFID Tag Reader Arduino Library.</p> RFID Reader RedBoard Artemis RX TX / D2 TX RX / D3 VIN 5V Ground Ground <p>Digital Pin Selections</p> <p>Digital pin values are the default selections for Software Serial in the Simulataneous RFID Reader Arduino Library and may be incompatible with your selected microcontroller. Refer to the Arduino Software Serial Reference for pin limitations for common microcontrollers.</p>"},{"location":"hardware_assembly/#power-supply-considerations","title":"Power Supply Considerations","text":"<p>When connecting the Simultaneous RFID Reader - M7E to a microcontroller, make sure your power supply can source sufficient current for your selected power level as the board can draw up to 720mA @5V at max read power level. The M7E's internal voltage regulator includes built-in protection that engages when the current draw reaches 1A and will not allow any more supply current to the module. As such, it is strongly recommended to use a 5V power supply when setting the read power to above +26 dBm.</p> <p>If you opt to power the RFID Reader from your development board's output voltage we recommend using the 5V out (if applicable) and then powering your development board through a dedicated power supply to avoid browning the circuit out as USB ports can only source ~500mA@5V. The image below shows the Simultaneous RFID Reader - M7E connected to the RedBoard IoT and powered with a dedicated power supply through the barrel jack.</p>"},{"location":"hardware_overview/","title":"Hardware Overview","text":"<p>In this section we'll take a closer look at the hardware present on the Simultaneous RFID Reader 3.3V.</p>"},{"location":"hardware_overview/#m7e-hecto-uhf-rfid-reader","title":"M7E Hecto UHF RFID Reader","text":"<p>The M7E Hecto is an Ultra-High Frequency (UHF) RFID reader capable of reading multiple tags simultaneously at up to 150 tags per second. </p> <p></p> <p>The module can also write data quickly to RFID tags with 96-bit EPC (80msec typical write time). The M7E Hecto boasts adjustable read and write RF power levels from 0dBm to 27dBm in 0.01dBm steps and can read tags from several feet away (even more than 16 feet in our testing!) with the proper antenna, conditions and device settings. The M7E-Hecto works with common, low-cost, passive, Gen2 UHF tags available from a variety of online vendors in a variety of shapes and sizes. We offer two types of UHF tags, ones with adhesive backing and ultra-small ones. Both have 64 bytes of user-writable memory.</p> <p>The M7E accepts a supply voltage between 3.3V and 5.5V and operates normally so long as the module's current draw is below 1A as it includes a built-in protection circuit that allows no more than 1A drawn to prevent damage to the M7E. Therefore, it's recommended to power the M7E with a 5V source to avoid hitting the current limit at higher read/write powers or when the GPIO and Vout lines are supplying current to other devices. Refer to section 5.2 of the M7E User Guide for detailed information on this limit as well as graphs showing typical current draw at various supply voltages as well as power requirements for different power settings.</p>"},{"location":"hardware_overview/#communication-interfaces","title":"Communication Interfaces","text":"<p>The board has two options for interacting with the M7E Hecto's serial interface: USB-C and a plated through-hole (PTH) header. The PTH header can connect to a microcontroller or serial converter (running at 3.3V logic or properly level-shifted). The selection switch on the board labeled UART allows users to choose between the two serial interface options. The board also breaks out several of the M7E Hecto's GPIO pins and the Enable pin.</p> <p></p>"},{"location":"hardware_overview/#usb-c","title":"USB-C","text":"<p>The USB-C connector on the board allows for quick use of the M7E Hecto with just a USB-C cable. The board uses a CH340C USB-to-Serial adapter to translate between the M7E's UART and the USB-C connection. </p> Heads Up! With RF power level set to 27dBm the board can draw over 700mA (3.6W @ 5V). Most USB ports on computers only source up to ~500mA so the board may start to brown out at power settings over 22dBm when powered from a USB port. Users who wish to set the over 22dBm should make sure their power source (either from USB-C via a power adapter or through a regulated 5V supply to the VIN PTH pin) can source enough current to power the board. We recommend a power adapter like this."},{"location":"hardware_overview/#through-hole-serial-connection","title":"Through-Hole Serial Connection","text":"<p>The board includes a PTH header for serial communication with a 3.3V microcontroller or other device. The header matches the pinout for our Serial Breakouts for easy connection to those devices.</p>"},{"location":"hardware_overview/#serial-selection-switch","title":"Serial Selection Switch","text":"<p>The two-way switch on the board labled UART allows the user to toggle between the two serial interfaces: USB-C (USB) and the Serial Header (SER).</p>"},{"location":"hardware_overview/#enable-and-gpio-pths","title":"Enable and GPIO PTHs","text":"<p>The M7E uses an internal DC to DC converter to provide itself with power. When the EN (enable) pin is pulled low the DC/DC converter is turned off and the module does a hard reset. EN can be left unconnected for normal operation. </p> <p>Warning</p> <p>Note: The 3.3V pin on this header is not intended as a power source. It connects to the V_OUT pin on the M7E Hecto which can only supply 5mA. It is best used as a voltage reference.</p>"},{"location":"hardware_overview/#power-led","title":"Power LED","text":"<p>The lone LED on the board indicates device power status. Users can disable this LED by severing the PWR jumper. The Power LED receives voltage from the VOUT pin on the M7E Hecto. Driving the EN pin low disables VOUT and can be used to turn this LED off.</p> <p></p>"},{"location":"hardware_overview/#solder-jumpers","title":"Solder Jumpers","text":"<p>The board has three solder jumpers labeled: PWR, VIN SEL, and SHLD. The table below outlines their label, function, default state, and any notes regarding their use.</p> <p></p> Label Default State Function Notes PWR CLOSED Completes Power LED circuit. Open to disable Power LED. VIN SEL CLOSED Nets V_USB, VIN, and VCC together. Three-way jumper that nets all voltage inputs together. Adjust to isolate any of these voltages from the others (or all three) if needed. SHLD CLOSED Ties USB Shield pin to PCB ground plane. Open to isolate the USB Shield pin from the rest of the board."},{"location":"hardware_overview/#ground-plane-heatsink","title":"Ground Plane Heatsink","text":"<p>The board has a large ground plane heatsink on the bottom to help dissipate heat generated by the module.</p> <p></p> <p>The exposed copper pour allows the connection to a heatsink such as a chassis or block of metal if needed. The M7E has an integrated temperature sensor that will monitor the internal temperature and can disable RF if the module is overheating and keeps it off until the recorded temperature drops back into the safe range (-40\u00b0C to +60\u00b0C). Attaching a heat sink to the exposed copper pour or adjusting the read power and/or duty cycle can help dissipate heat to prevent this throttling in long-period applications of this board. Refer to the thermal management considerations of this guide or section 5.4 of the M7E User Guide for more information.</p>"},{"location":"hardware_overview/#antenna-options","title":"Antenna Options","text":"<p>The Hecto M7E is a powerful transmitter capable of outputting up to 27dBm! That's a lot. The board comes with a PCB trace antenna and a u.FL connector for an external antenna connection.</p> <p></p> <p>The trace antenna is enabled by default. Adjust the RF resistor to switch the antenna signal to the u.FL connector to use an external antenna. Refer to the Using an External Antenna section of this guide for more information on this assembly step.</p>"},{"location":"hardware_overview/#board-dimensions","title":"Board Dimensions","text":"<p>The board measures 2.40\" x 1.40\" (60.96mm x 35.56mm) and has four mounting holes that fit a 4-40 screw.</p> <p></p>"},{"location":"introduction/","title":"Introduction","text":"<ul> <li> <p> SparkFun Simultaneous RFID Reader - M7E Hecto SKU: WRL-24738 <p> </p> <p> </p> <li> <p>The M7E Hecto is a Ultra-High Frequency (UHF) RFID reader from JADAK<sup>\u00a9</sup> capable of reading multiple tags simultaneously at up to 150 tags per second and can also write data to tags. The M7E Hecto can read tags from several feet away (up to 16 feet in our testing!) with the proper antenna, conditions and device settings. This board includes a USB-C connector and CH340C USB to UART converter to quickly connect the board to a computer and read tags with no soldering required.</p> <p>Along with the USB-C connector, the Simultaneous RFID Reader 3.3V has a 0.1\"-spaced PTH header for connecting it to an external converter or to a 3.3V microcontroller of your choice to use it with the SparkFun Simultaneous RFID Tag Reader Library. A 2-way switch on the board allows for easy switching between the included communication interfaces.</p> <p> Purchase from SparkFun  </p> </li> <p>In this guide we'll cover everything you need to set up this RFID reader and use it with the Universal Reader Assistant application to read and write to UHF tags. We'll also cover how to set this board up in a circuit with a 3.3V microcontroller and point you to where you can get started using the SparkFun Simultaneous RFID Tag Reader Arduino Library.</p>"},{"location":"introduction/#required-materials","title":"Required Materials","text":"<p>We designed this version of the Simultaneous RFID Reader to work over either USB-C or a serial plated through-hole (PTH) connection so depending on your application, you may need different materials. </p>"},{"location":"introduction/#usb-connection","title":"USB Connection","text":"<p>The quickest way to get the RFID Reader up and running is through the USB-C connector. If you opt for this you'll need a USB-C cable like the ones below:</p> <ul> <li> <p> <p> </p> <p> USB 3.1 Cable A to C - 3 Foot CAB-14743 </p> <li> <p> <p> </p> <p> Reversible USB A to C Cable - 2m CAB-15424 </p> <li> <p> <p> </p> <p> Reversible USB A to C Cable - 0.8m CAB-15425 </p> <li> <p> <p> </p> <p> Reversible USB A to C Cable - 0.3m CAB-15426 </p>"},{"location":"introduction/#pth-serial-connection","title":"PTH Serial Connection","text":"<p>Users who prefer to use the PTH headers to connect to a serial converter or microcontroller will want to solder either wire or a set of header pins to the board to make connections to the external device. If you don't have wire, header pins or soldering tools you may want to add the products below to your cart:</p> <p>Logic Levels</p> <p>Note: The serial output on the Simultaneous RFID Reader - M7E  operates at 3.3V logic so make sure the microcontroller or serial converter connected to this interface operates at 3.3V or are properly level-shifted.</p> <ul> <li> <p> <p> </p> <p> SparkFun Serial Basic Breakout - CH340C and USB-C DEV-15096 </p> <li> <p> <p> </p> <p> SparkFun FTDI Basic Breakout - 3.3V DEV-09873 </p> <li> <p> <p> </p> <p> SparkFun IoT RedBoard - ESP32 Development Board DEV-19177 </p> <li> <p> <p> </p> <p> SparkFun RedBoard Artemis DEV-15444 </p> <li> <p> <p> </p> <p> Soldering Iron - 60W (Adjustable Temperature) TOL-14456 </p> <li> <p> <p> </p> <p> Solder Lead Free - 100-gram Spool TOL-09325 </p> <li> <p> <p> </p> <p> Hook-Up Wire - Assortment (Stranded, 22 AWG) PRT-11375 </p> <li> <p> <p> </p> <p> Break Away Male Headers - Right Angle SKU </p>"},{"location":"introduction/#additional-materials","title":"Additional Materials","text":"<p>You'll also need UHF RFID tags for the M7E Hecto to read/write. For best range performance you'll need an external antenna along with the appropriate adapter cables. We'll demonstrate how to connect the external antenna using the cables listed below:</p> <ul> <li> <p> <p> </p> <p> UHF RFID Antenna (RP-TNC) WRL-14131 </p> <li> <p> <p> </p> <p> RP-SMA to U.FL Cable - 150mm WRL-18569 </p> <li> <p> <p> </p> <p> UHF RFID Tags - 30mm x 16mm (Adhesive) WRL-20226 </p> <li> <p> <p> </p> <p> Interface Cable for RP-TNC to RP-SMA - 1m CAB-14132 </p>"},{"location":"introduction/#suggested-reading","title":"Suggested Reading","text":"<p>If you aren't familiar with the following concepts, we recommend reading through these tutorials before continuing with this guide.</p> <ul> <li> <p> Serial Communication </p> </li> <li> <p> Logic Levels </p> </li> <li> <p> RFID Basics </p> </li> <li> <p> Installing Arduino IDE </p> </li> <li> <p> Installing an Arduino Library </p> </li> <li> <p> Serial Terminal Basics </p> </li> <li> <p> Three Quick Tips About Using U.FL <li> <p> How to Work with Jumper Pads and PCB Traces </p> </li>"},{"location":"print_view/","title":"Introduction","text":"<ul> <li> <p> SparkFun Simultaneous RFID Reader - M7E Hecto SKU: WRL-24738 <p> </p> <p> </p> <li> <p>The M7E Hecto is a Ultra-High Frequency (UHF) RFID reader from JADAK<sup>\u00a9</sup> capable of reading multiple tags simultaneously at up to 150 tags per second and can also write data to tags. The M7E Hecto can read tags from several feet away (up to 16 feet in our testing!) with the proper antenna, conditions and device settings. This board includes a USB-C connector and CH340C USB to UART converter to quickly connect the board to a computer and read tags with no soldering required.</p> <p>Along with the USB-C connector, the Simultaneous RFID Reader 3.3V has a 0.1\"-spaced PTH header for connecting it to an external converter or to a 3.3V microcontroller of your choice to use it with the SparkFun Simultaneous RFID Tag Reader Library. A 2-way switch on the board allows for easy switching between the included communication interfaces.</p> <p> Purchase from SparkFun  </p> </li> <p>In this guide we'll cover everything you need to set up this RFID reader and use it with the Universal Reader Assistant application to read and write to UHF tags. We'll also cover how to set this board up in a circuit with a 3.3V microcontroller and point you to where you can get started using the SparkFun Simultaneous RFID Tag Reader Arduino Library.</p>"},{"location":"print_view/#required-materials","title":"Required Materials","text":"<p>We designed this version of the Simultaneous RFID Reader to work over either USB-C or a serial plated through-hole (PTH) connection so depending on your application, you may need different materials. </p>"},{"location":"print_view/#usb-connection","title":"USB Connection","text":"<p>The quickest way to get the RFID Reader up and running is through the USB-C connector. If you opt for this you'll need a USB-C cable like the ones below:</p> <ul> <li> <p> <p> </p> <p> USB 3.1 Cable A to C - 3 Foot CAB-14743 </p> <li> <p> <p> </p> <p> Reversible USB A to C Cable - 2m CAB-15424 </p> <li> <p> <p> </p> <p> Reversible USB A to C Cable - 0.8m CAB-15425 </p> <li> <p> <p> </p> <p> Reversible USB A to C Cable - 0.3m CAB-15426 </p>"},{"location":"print_view/#pth-serial-connection","title":"PTH Serial Connection","text":"<p>Users who prefer to use the PTH headers to connect to a serial converter or microcontroller will want to solder either wire or a set of header pins to the board to make connections to the external device. If you don't have wire, header pins or soldering tools you may want to add the products below to your cart:</p> <p>Logic Levels</p> <p>Note: The serial output on the Simultaneous RFID Reader - M7E  operates at 3.3V logic so make sure the microcontroller or serial converter connected to this interface operates at 3.3V or are properly level-shifted.</p> <ul> <li> <p> <p> </p> <p> SparkFun Serial Basic Breakout - CH340C and USB-C DEV-15096 </p> <li> <p> <p> </p> <p> SparkFun FTDI Basic Breakout - 3.3V DEV-09873 </p> <li> <p> <p> </p> <p> SparkFun IoT RedBoard - ESP32 Development Board DEV-19177 </p> <li> <p> <p> </p> <p> SparkFun RedBoard Artemis DEV-15444 </p> <li> <p> <p> </p> <p> Soldering Iron - 60W (Adjustable Temperature) TOL-14456 </p> <li> <p> <p> </p> <p> Solder Lead Free - 100-gram Spool TOL-09325 </p> <li> <p> <p> </p> <p> Hook-Up Wire - Assortment (Stranded, 22 AWG) PRT-11375 </p> <li> <p> <p> </p> <p> Break Away Male Headers - Right Angle SKU </p>"},{"location":"print_view/#additional-materials","title":"Additional Materials","text":"<p>You'll also need UHF RFID tags for the M7E Hecto to read/write. For best range performance you'll need an external antenna along with the appropriate adapter cables. We'll demonstrate how to connect the external antenna using the cables listed below:</p> <ul> <li> <p> <p> </p> <p> UHF RFID Antenna (RP-TNC) WRL-14131 </p> <li> <p> <p> </p> <p> RP-SMA to U.FL Cable - 150mm WRL-18569 </p> <li> <p> <p> </p> <p> UHF RFID Tags - 30mm x 16mm (Adhesive) WRL-20226 </p> <li> <p> <p> </p> <p> Interface Cable for RP-TNC to RP-SMA - 1m CAB-14132 </p>"},{"location":"print_view/#suggested-reading","title":"Suggested Reading","text":"<p>If you aren't familiar with the following concepts, we recommend reading through these tutorials before continuing with this guide.</p> <ul> <li> <p> Serial Communication </p> </li> <li> <p> Logic Levels </p> </li> <li> <p> RFID Basics </p> </li> <li> <p> Installing Arduino IDE </p> </li> <li> <p> Installing an Arduino Library </p> </li> <li> <p> Serial Terminal Basics </p> </li> <li> <p> Three Quick Tips About Using U.FL <li> <p> How to Work with Jumper Pads and PCB Traces </p> </li>"},{"location":"print_view/#hardware-overview","title":"Hardware Overview","text":"<p>In this section we'll take a closer look at the hardware present on the Simultaneous RFID Reader 3.3V.</p>"},{"location":"print_view/#m7e-hecto-uhf-rfid-reader","title":"M7E Hecto UHF RFID Reader","text":"<p>The M7E Hecto is an Ultra-High Frequency (UHF) RFID reader capable of reading multiple tags simultaneously at up to 150 tags per second. </p> <p></p> <p>The module can also write data quickly to RFID tags with 96-bit EPC (80msec typical write time). The M7E Hecto boasts adjustable read and write RF power levels from 0dBm to 27dBm in 0.01dBm steps and can read tags from several feet away (even more than 16 feet in our testing!) with the proper antenna, conditions and device settings. The M7E-Hecto works with common, low-cost, passive, Gen2 UHF tags available from a variety of online vendors in a variety of shapes and sizes. We offer two types of UHF tags, ones with adhesive backing and ultra-small ones. Both have 64 bytes of user-writable memory.</p> <p>The M7E accepts a supply voltage between 3.3V and 5.5V and operates normally so long as the module's current draw is below 1A as it includes a built-in protection circuit that allows no more than 1A drawn to prevent damage to the M7E. Therefore, it's recommended to power the M7E with a 5V source to avoid hitting the current limit at higher read/write powers or when the GPIO and Vout lines are supplying current to other devices. Refer to section 5.2 of the M7E User Guide for detailed information on this limit as well as graphs showing typical current draw at various supply voltages as well as power requirements for different power settings.</p>"},{"location":"print_view/#communication-interfaces","title":"Communication Interfaces","text":"<p>The board has two options for interacting with the M7E Hecto's serial interface: USB-C and a plated through-hole (PTH) header. The PTH header can connect to a microcontroller or serial converter (running at 3.3V logic or properly level-shifted). The selection switch on the board labeled UART allows users to choose between the two serial interface options. The board also breaks out several of the M7E Hecto's GPIO pins and the Enable pin.</p> <p></p>"},{"location":"print_view/#usb-c","title":"USB-C","text":"<p>The USB-C connector on the board allows for quick use of the M7E Hecto with just a USB-C cable. The board uses a CH340C USB-to-Serial adapter to translate between the M7E's UART and the USB-C connection. </p> Heads Up! With RF power level set to 27dBm the board can draw over 700mA (3.6W @ 5V). Most USB ports on computers only source up to ~500mA so the board may start to brown out at power settings over 22dBm when powered from a USB port. Users who wish to set the over 22dBm should make sure their power source (either from USB-C via a power adapter or through a regulated 5V supply to the VIN PTH pin) can source enough current to power the board. We recommend a power adapter like this."},{"location":"print_view/#through-hole-serial-connection","title":"Through-Hole Serial Connection","text":"<p>The board includes a PTH header for serial communication with a 3.3V microcontroller or other device. The header matches the pinout for our Serial Breakouts for easy connection to those devices.</p>"},{"location":"print_view/#serial-selection-switch","title":"Serial Selection Switch","text":"<p>The two-way switch on the board labled UART allows the user to toggle between the two serial interfaces: USB-C (USB) and the Serial Header (SER).</p>"},{"location":"print_view/#enable-and-gpio-pths","title":"Enable and GPIO PTHs","text":"<p>The M7E uses an internal DC to DC converter to provide itself with power. When the EN (enable) pin is pulled low the DC/DC converter is turned off and the module does a hard reset. EN can be left unconnected for normal operation. </p> <p>Warning</p> <p>Note: The 3.3V pin on this header is not intended as a power source. It connects to the V_OUT pin on the M7E Hecto which can only supply 5mA. It is best used as a voltage reference.</p>"},{"location":"print_view/#power-led","title":"Power LED","text":"<p>The lone LED on the board indicates device power status. Users can disable this LED by severing the PWR jumper. The Power LED receives voltage from the VOUT pin on the M7E Hecto. Driving the EN pin low disables VOUT and can be used to turn this LED off.</p> <p></p>"},{"location":"print_view/#solder-jumpers","title":"Solder Jumpers","text":"<p>The board has three solder jumpers labeled: PWR, VIN SEL, and SHLD. The table below outlines their label, function, default state, and any notes regarding their use.</p> <p></p> Label Default State Function Notes PWR CLOSED Completes Power LED circuit. Open to disable Power LED. VIN SEL CLOSED Nets V_USB, VIN, and VCC together. Three-way jumper that nets all voltage inputs together. Adjust to isolate any of these voltages from the others (or all three) if needed. SHLD CLOSED Ties USB Shield pin to PCB ground plane. Open to isolate the USB Shield pin from the rest of the board."},{"location":"print_view/#ground-plane-heatsink","title":"Ground Plane Heatsink","text":"<p>The board has a large ground plane heatsink on the bottom to help dissipate heat generated by the module.</p> <p></p> <p>The exposed copper pour allows the connection to a heatsink such as a chassis or block of metal if needed. The M7E has an integrated temperature sensor that will monitor the internal temperature and can disable RF if the module is overheating and keeps it off until the recorded temperature drops back into the safe range (-40\u00b0C to +60\u00b0C). Attaching a heat sink to the exposed copper pour or adjusting the read power and/or duty cycle can help dissipate heat to prevent this throttling in long-period applications of this board. Refer to the thermal management considerations of this guide or section 5.4 of the M7E User Guide for more information.</p>"},{"location":"print_view/#antenna-options","title":"Antenna Options","text":"<p>The Hecto M7E is a powerful transmitter capable of outputting up to 27dBm! That's a lot. The board comes with a PCB trace antenna and a u.FL connector for an external antenna connection.</p> <p></p> <p>The trace antenna is enabled by default. Adjust the RF resistor to switch the antenna signal to the u.FL connector to use an external antenna. Refer to the Using an External Antenna section of this guide for more information on this assembly step.</p>"},{"location":"print_view/#board-dimensions","title":"Board Dimensions","text":"<p>The board measures 2.40\" x 1.40\" (60.96mm x 35.56mm) and has four mounting holes that fit a 4-40 screw.</p> <p></p>"},{"location":"print_view/#hardware-assembly-simple-assembly","title":"Hardware Assembly - Simple Assembly","text":"<p>In this section we'll cover the two ways to set up the Simultaneous RFID Reader - M7E over both USB-C and connected to a microcontroller for use with the SparkFun Simultaneous RFID Reader Arduino Library. </p>"},{"location":"print_view/#communicating-via-usb-c-serial","title":"Communicating via USB-C Serial","text":"<p>The fastest and easiest way to start using the board is through the USB-C connector. Simply plug the board into a computer with a USB-C cable and open up the Universal Reader Assistant.</p> <p></p> <p>Reminder, many computer USB ports can only supply ~500mA @5V which limits the power level settings to roughly 20dBm and lower. Running the M7E at higher power levels may require a dedicated power supply.</p>"},{"location":"print_view/#communicating-via-serial-pth-header","title":"Communicating via Serial PTH Header","text":"<p>Users who prefer to communicate with the RFID reader using the Serial PTH header should solder either wires or header pins to connect them to a 3.3V microcontroller (you can also use this to connect to a USB UART board like the Serial Basic. If you are not familiar with through-hole soldering or would like a refresher, take a read through this tutorial.</p> <p></p> <p>We'll demonstrate soldering male headers to the board and use jumper wires to connect the RFID Reader to the SparkFun RedBoard Artemis for use with the SparkFun Simultaneous RFID Tag Reader Arduino Library.</p> RFID Reader RedBoard Artemis RX TX / D2 TX RX / D3 VIN 5V Ground Ground <p>Digital Pin Selections</p> <p>Digital pin values are the default selections for Software Serial in the Simulataneous RFID Reader Arduino Library and may be incompatible with your selected microcontroller. Refer to the Arduino Software Serial Reference for pin limitations for common microcontrollers.</p>"},{"location":"print_view/#power-supply-considerations","title":"Power Supply Considerations","text":"<p>When connecting the Simultaneous RFID Reader - M7E to a microcontroller, make sure your power supply can source sufficient current for your selected power level as the board can draw up to 720mA @5V at max read power level. The M7E's internal voltage regulator includes built-in protection that engages when the current draw reaches 1A and will not allow any more supply current to the module. As such, it is strongly recommended to use a 5V power supply when setting the read power to above +26 dBm.</p> <p>If you opt to power the RFID Reader from your development board's output voltage we recommend using the 5V out (if applicable) and then powering your development board through a dedicated power supply to avoid browning the circuit out as USB ports can only source ~500mA@5V. The image below shows the Simultaneous RFID Reader - M7E connected to the RedBoard IoT and powered with a dedicated power supply through the barrel jack.</p>"},{"location":"print_view/#hardware-assembly-using-an-external-antenna","title":"Hardware Assembly - Using an External Antenna","text":"<p>The integrated PCB antenna works well over short distances but users who want to get the maximum range for the M7E Hecto should consider using an external antenna. Connecting an external antenna to the Simultaneous RFID Reader - M7E requires some hardware adjustments, minor assembly steps and other considerations regarding the antenna. Let's go over these adjustments and considerations. </p>"},{"location":"print_view/#fcc-regulations","title":"FCC Regulations","text":"<p>From section 5.8 of the M7E Hecto User Guide:</p> <p>No additional transmitter-compliance testing is required if the module is operated with the same type of antenna as listed in the FCC filing, as long as it has equal or lower gain than the antenna listed. Equivalent antennas must be of the same general type (e.g. dipole, circularly polarized patch, etc.), and must have similar in-band and out-of-band characteristics (consult specification sheet for cutoff frequencies).</p> <p>The board's PCB trace antenna is a patch antenna with a much lower gain than the list of approved antennas which allows the use of an unmodified board in the field without additional FCC testing.</p> <p>The u.FL connector allows users to connect higher-gain directional antennas. However, there are stipulations as to what external antennas can be used and additional FCC certifications may be required. </p> <p>Info</p> <p>Note: The onboard PCB antenna complies with the FCC regulation.</p> <p>The list below from section 5.7 of the M7E Hecto User Guide outlines antennas ThingMagic has tested and gotten approved by the FCC. You may use a different antenna from the ones in the list but it must be of equal or less gain than an antenna previously authorized under the same FCC ID and must have similar in-band and out-of0band characteristics (consult specification sheet for cut-off frequencies) if used in a product without additional testing.</p> <p></p> List of approved antenas"},{"location":"print_view/#attaching-the-external-antenna","title":"Attaching the External Antenna","text":"<p>Switching to the external antenna connection requires changing the position of the antenna (labeled RF) resistor to route the M7E's antenna signal to the u.FL connector on the board.</p> <p>Adjusting from PCB Antenna to u.FL Connection</p> <p>Note:  You do not need an external antenna for basic use of the Simultaneous RFID Reader - M7E but the PCB antenna reads tags reliably at only up to a few inches away at the highest read power and with the PCB antenna positioned away from any solid surfaces. If you want to take advantage of the full range, follow the steps below to modify the board and enable the u.FL connector for an external antenna connection. </p> <p>If you have never worked with surface mount components, we recommend reading through these tutorials:</p> <ul> <li> <p> How to Use a Hot Air Rework Station </p> </li> <li> <p> How to Solder: Through-Hole Soldering - Advanced SMD </p> </li> </ul> <p>Carefully reflow the 0k\u03a9 resistor labeled RF to move it to the u.FL position. You can either use a soldering iron or hot-air rework station to reflow the solder holding the resistor into place. The photo below shows the RF resistor after adjusting it to the u.FL position.</p> <p></p> Take careful note of the position of this resistor in the photo to make sure it is in the correct position. <p>Next, attach the u.FL to the RP-SMA connector cable. Because this connector is fragile we recommend either taping or hot gluing the sheath of the cable to the PCB. This will help prevent damage to the u.FL connector in case the cable gets pulled on.</p> <p></p> <p>To get the best range we recommend attaching an external high-gain antenna to a tripod of some sort. If you only have a desk, that's ok too.</p> <p></p> <p>We used the included hardware with the antenna to attach it to the leg of the tripod. </p> <p></p> <p>Now connect the RP-SMA to RP-TNC cable. And finally, connect the RP-TNC to the external antenna. You can use a different UHF RFID antenna but you will need to have the correct connectors and cables to go from the u.FL connector on the board to the connector on your specific antenna.</p> <p></p> <p>Warning</p> <p>Don't Forget! Ensure that personnel do not stand in the radiation beam of the antenna unless they are more than 21cm away from the face of the antenna (to adhere to FCC limits for long-term exposure). Refer to the M7E Hecto design guide for more information.</p>"},{"location":"print_view/#hardware-assembly-thermal-management-considerations","title":"Hardware Assembly - Thermal Management Considerations","text":"<p>The module can reach temperatures greater than 85\u00b0C (185\u00b0F) when operating at full read power over extended periods so thermal management is an important consideration using this board. </p> <p>The module will automatically throttle itself to prevent permanent damage from heat. This board provides enough ground plane heatsinking to allow the module to operate at full read power for tens of minutes before throttling occurs. If you plan to operate the module at full power for extended periods (over an hour) we recommend attaching a heatsink. </p> <p>You can get the 1:1 dimensional drawing of the board here. The dimensional drawing below shows the exposed thermal pad and mounting holes. </p> <p></p> Dimensional Drawing showing the mounting holes and exposed thermal pad <p>Heatsinking won\u2019t be required in most prototyping applications. However, if you have heat-sensitive items near the module (such as temperature or humidity sensors) they may be influenced by the module. If you are planning to install the module for long-term operation we recommend attaching a heatsink with thermal compound for best results.</p> <p>The module also supports changing the read duty cycle to reduce heat dissipation as well. Refer to the M7E-Hecto Design Guide for more information.</p>"},{"location":"print_view/#using-the-thingmagic-universal-reader-assistant","title":"Using the ThingMagic Universal Reader Assistant","text":"<p>Start by downloading the Universal Reader Assistant (URA). 32-bit and 64-bit versions are available.</p> <p> Universal Reader Assistant Download </p> <p>Open the installer once downloading finishes and follow the installation wizard instructions.</p>"},{"location":"print_view/#universal-reader-assistant-setup-wizard","title":"Universal Reader Assistant Setup Wizard","text":"<p>Make sure the Simultaneous RFID Reader is plugged in either over USB or through the Serial Header to a USB-to-Serial converter with the UART selection switch in the correct position, and open the Universal Reader Assistant. You should be greeted by the Connection Wizard menu to select the reader type and port:</p> <p></p> <p>You can skip this selection and move on to the main menu of the Universal Reader Assistant. Otherwise, select the port your Simultaneous RFID Reader is on and click \"Next\" and the Connection Wizard should show you the RFID reader settings:</p> <p></p> <p>Click either \"Connect &amp; Read\" or \"Connect\" to open up the Universal Reader Assistant main window.</p>"},{"location":"print_view/#universal-reader-assistant-main-window","title":"Universal Reader Assistant Main Window","text":"<p>The main window of the Universal Reader Assistant contains a whole bunch of settings and status menus to adjust everything from the M7E's read/write options, power level and even perform firmware updates. It also has a handy readout for the M7E's internal temperature along with multiple tabs for interacting with tags the M7E sees including simple tag data, writing to the user memory and also locking a tag with a custom password.</p> <p>There are a ton of features to the M7E from ThingMagic. Poke around the Universal Reader Assistant to learn more. Write EPC and User Memory are two of the most commonly used tabs.</p> <p>Info</p> <p>Note: The \u2018Transport Logging\u2019 checkbox is very handy. Select this box and all the serial communication will be recorded to a log file. These HEX bytes can be deciphered and recreated using an Arduino or other microcontroller if you need a particular capability or feature that is not supported in the SparkFun Simultaneous RFID Reader Arduino library.</p>"},{"location":"print_view/#thermal-throttling","title":"Thermal Throttling","text":"<p>If you see this window pop up it means the module is reporting a temperature-limit fault condition. The module has an internal temperature sensor and will protect itself from permanent damage. You\u2019ll need to lower your read power or add heatsinking. See the previous section of this guide, Thermal Considerations, for more information.</p>"},{"location":"print_view/#sparkfun-simultaneous-rfid-reader-arduino-library-library-setup","title":"SparkFun Simultaneous RFID Reader Arduino Library - Library Setup","text":"<p>Attention</p> <p>If this is your first time using Arduino, please read through our tutorial on installing the Arduino IDE. If you have not installed an Arduino library before, we recommend you check out our installation guide.</p> <p>The SparkFun Simultaneous RFID Tag Reader Arduino library, while originally written for the M6E-NANO, works just as well for the M7E-HECTO on this RFID Reader breakout. The library handles all serial communication, byte manipulations, and CRC verifications making it easy to quickly get started using the board. Users can download and install the library through the Arduino Library Manager by searching for \"SparkFun Simultaneous RFID\" and selecting the latest version. If you prefer to manually install the library, download a ZIP of it by clicking the button below:</p> <p> SparkFun Simultaneous RFID Tag Reader Arduino Library (ZIP) </p> <p>With the library installed, let's take a closer look at some of the examples included in it. You can take a look at them by navigating to File &gt; Examples &gt; SparkFun Simultaneous RFID Tag Reader Library &gt; Examples.</p>"},{"location":"print_view/#sparkfun-simultaneous-rfid-reader-arduino-library-arduino-examples","title":"SparkFun Simultaneous RFID Reader Arduino Library - Arduino Examples","text":"<p>Let's take an in-depth look at most of the examples included in the SparkFun Simultaneous RFID Reader Arduino Library.</p>"},{"location":"print_view/#uart-switch-position-software-serial","title":"UART Switch Position &amp; Software Serial","text":"<p>Make sure the Serial Selection Switch is in the \"SER\" position when using this library. All of the examples in this Arduino library use the Software Serial Library so if you are not using the SparkFun RedBoard IoT and following the assembly instructions in the Hardware Assembly section, make sure to connect the RX/TX pins on the SER header to compatible pins on your chosen development board. Note, this library </p>"},{"location":"print_view/#code-to-note","title":"Code to Note","text":"<p>The latest version of the Simultaneous RFID Reader Library has a couple of settings to take note of and adjust accordingly depending on your hardware and setup.</p>"},{"location":"print_view/#serial-selection-software-vs-hardware","title":"Serial Selection (Software vs Hardware)","text":"<p>If you're using a development board that supports Software Serial, uncomment the following lines and adjust the pins for RX/TX if necessary:</p> <pre><code>#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n</code></pre> <p>The next option selects which type of serial is used. The code lists a couple of examples for both software serial and hardware so adjust the definition as needed. For example, if you're using a software serial library, define this as <code>softserial</code>. If you're using a hardware serial port on your development board, select the serial port (eg. Serial1) as shown below: </p> <pre><code>// #define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n#define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n</code></pre>"},{"location":"print_view/#baud-rate-selection","title":"Baud Rate Selection","text":"<p>Next, you'll want to define the baud rate for <code>rfidBaud</code>. We recommend using the settings shown below with 38400 when using software serial and 115200 when using hardware serial:</p> <pre><code>// #define rfidBaud 38400\n#define rfidBaud 115200\n</code></pre>"},{"location":"print_view/#module-selection","title":"Module Selection","text":"<p>Since this library supports both the M6E Nano and M7E Hecto, you'll need to define which module you are using. Adjust or comment/uncomment the <code>moduleType</code> definition to set it to the correct module:</p> <pre><code>// #define moduleType ThingMagic_M6E_NANO\n#define moduleType ThingMagic_M7E_HECTO\n</code></pre>"},{"location":"print_view/#example-1-constant-read","title":"Example 1 - Constant Read","text":"<p>The first example sets the M7E to constantly scan and report any tags it sees in the vicinity. Open the example by navigating to File &gt; Examples &gt; SparkFun Simultaneous RFID Reader Library &gt; Example 1 Constant Read. Select your Board and Port and click the \"Upload\" button. Once the code finishes uploading, open the serial monitor with the baud set to 115200. </p> Example 1 - Constant Read <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Constantly reads and outputs any tags heard\n\n  If using the Simultaneous RFID Tag Reader (SRTR) shield, make sure the serial slide\n  switch is in the 'SW-UART' position\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n  while (!Serial); //Wait for the serial port to come online\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(F(\"Module failed to respond. Please check wiring.\"));\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may caues USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n  Serial.println(F(\"Press a key to begin scanning for tags.\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  rfidModule.startReading(); //Begin scanning for tags\n}\n\nvoid loop()\n{\n  if (rfidModule.check() == true) //Check to see if any new data has come in from module\n  {\n    byte responseType = rfidModule.parseResponse(); //Break response into tag ID, RSSI, frequency, and timestamp\n\n    if (responseType == RESPONSE_IS_KEEPALIVE)\n    {\n      Serial.println(F(\"Scanning\"));\n    }\n    else if (responseType == RESPONSE_IS_TAGFOUND)\n    {\n      //If we have a full record we can pull out the fun bits\n      int rssi = rfidModule.getTagRSSI(); //Get the RSSI for this tag read\n\n      long freq = rfidModule.getTagFreq(); //Get the frequency this tag was detected at\n\n      long timeStamp = rfidModule.getTagTimestamp(); //Get the time this was read, (ms) since last keep-alive message\n\n      byte tagEPCBytes = rfidModule.getTagEPCBytes(); //Get the number of bytes of EPC from response\n\n      Serial.print(F(\" rssi[\"));\n      Serial.print(rssi);\n      Serial.print(F(\"]\"));\n\n      Serial.print(F(\" freq[\"));\n      Serial.print(freq);\n      Serial.print(F(\"]\"));\n\n      Serial.print(F(\" time[\"));\n      Serial.print(timeStamp);\n      Serial.print(F(\"]\"));\n\n      //Print EPC bytes, this is a subsection of bytes from the response/msg array\n      Serial.print(F(\" epc[\"));\n      for (byte x = 0 ; x &lt; tagEPCBytes ; x++)\n      {\n        if (rfidModule.msg[31 + x] &lt; 0x10) Serial.print(F(\"0\")); //Pretty print\n        Serial.print(rfidModule.msg[31 + x], HEX);\n        Serial.print(F(\" \"));\n      }\n      Serial.print(F(\"]\"));\n\n      Serial.println();\n    }\n    else if (responseType == ERROR_CORRUPT_RESPONSE)\n    {\n      Serial.println(\"Bad CRC\");\n    }\n    else if (responseType == RESPONSE_IS_HIGHRETURNLOSS)\n    {\n      Serial.println(\"High return loss, check antenna!\");\n    }\n    else\n    {\n      //Unknown response\n      Serial.println(\"Unknown error\");\n    }\n  }\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p>The code attempts to set up the module with the defined baud rate and if that fails, it prints \"Module failed to respond. Please check wiring\" If you see this prompt, double-check your connections to your development board and retry. On successful module startup and setup, the code prints \"Press a key to begin scanning for tags.\" Send any key message and the M7E will begin to scan for any tags in range and print out their EPC as the screenshot below shows:</p> <p></p>"},{"location":"print_view/#example-2-read-epc","title":"Example 2 - Read EPC","text":"<p>The second example demonstrates how to perform a single-shot read of one tag in the reader's range and print out the EPC value over serial. This example uses the <code>.readTagEPC()</code> function to pass it an array of bytes (in almost all cases EPCs are 12 bytes), the size of the array (12), and the amount of time to scan before giving up (500ms is default). This returns RESPONSE_SUCCESS when the M7E detects a tag and stores the EPC in the array given.</p> Example 2 - Read EPC <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Single shot read - Ask the reader to tell us what tags it currently sees. And it beeps!\n\n  If using the Simultaneous RFID Tag Reader (SRTR) shield, make sure the serial slide\n  switch is in the 'SW-UART' position.\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\n#define BUZZER1 9\n//#define BUZZER1 0 //For testing quietly\n#define BUZZER2 10\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  pinMode(BUZZER1, OUTPUT);\n  pinMode(BUZZER2, OUTPUT);\n\n  digitalWrite(BUZZER2, LOW); //Pull half the buzzer to ground and drive the other half.\n\n  while (!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Press a key to scan for a tag\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  byte myEPC[12]; //Most EPCs are 12 bytes\n  byte myEPClength;\n  byte responseType = 0;\n\n  while (responseType != RESPONSE_SUCCESS)//RESPONSE_IS_TAGFOUND)\n  {\n    myEPClength = sizeof(myEPC); //Length of EPC is modified each time .readTagEPC is called\n\n    responseType = rfidModule.readTagEPC(myEPC, myEPClength, 500); //Scan for a new tag up to 500ms\n    Serial.println(F(\"Searching for tag\"));\n  }\n\n  //Beep! Piano keys to frequencies: http://www.sengpielaudio.com/KeyboardAndFrequencies.gif\n  tone(BUZZER1, 2093, 150); //C\n  delay(150);\n  tone(BUZZER1, 2349, 150); //D\n  delay(150);\n  tone(BUZZER1, 2637, 150); //E\n  delay(150);\n\n  //Print EPC\n  Serial.print(F(\" epc[\"));\n  for (byte x = 0 ; x &lt; myEPClength ; x++)\n  {\n    if (myEPC[x] &lt; 0x10) Serial.print(F(\"0\"));\n    Serial.print(myEPC[x], HEX);\n    Serial.print(F(\" \"));\n  }\n  Serial.println(F(\"]\"));\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p></p> <p>Note, this example also includes definitions and code to set up and use the buzzer found on the Simultaneous RFID Reader - M6E Nano which is not present on the Simultaneous RFID Reader - M7E though users can wire a buzzer like this for an audio feedback when a tag is scanned.</p>"},{"location":"print_view/#example-3-write-epc","title":"Example 3 - Write EPC","text":"<p>Example 3 shows how to write a character string and store it as a custom EPC value. This is a great way to keep track of which tag is which by setting the EPC to something like <code>WRENCH</code> or <code>PILL#317</code>. Note, EPCs can only be written in an even number of bytes like the example sets it to:</p> Example 3 - Write EPC <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Write a new EPC (Electronic Product Code) to a tag\n  This is a good way to assign your own, easy to read ID to a tag.\n  Most tags have 12 bytes available for EPC\n\n  EPC is good for things like UPC (this is a gallon of milk)\n  User data is a good place to write things like the milk's best by date\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while (!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n  rfidModule.setWritePower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Write TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Get all tags out of the area. Press a key to write EPC to first detected tag.\"));\n  if (Serial.available()) Serial.read(); //Clear any chars in the incoming buffer (like a newline char)\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  //\"Hello\" Does not work. \"Hell\" will be recorded. You can only write even number of bytes\n  //char stringEPC[] = \"Hello!\"; //You can only write even number of bytes\n  //byte responseType = nano.writeTagEPC(stringEPC, sizeof(stringEPC) - 1); //The -1 shaves off the \\0 found at the end of string\n\n  char hexEPC[] = {0xFF, 0x2D, 0x03, 0x54}; //You can only write even number of bytes\n  byte responseType = rfidModule.writeTagEPC(hexEPC, sizeof(hexEPC));\n\n  if (responseType == RESPONSE_SUCCESS)\n    Serial.println(\"New EPC Written!\");\n  else\n    Serial.println(\"Failed write\");\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p><pre><code>char stringEPC[] = \"Hello!\"; //You can only write even number of bytes\nbyte responseType = nano.writeTagEPC(stringEPC, sizeof(stringEPC) - 1); //The -1 shaves off the \\0 found at the end of string\n</code></pre> This example also introduces a new function <code>setWritePower()</code>. This sets the power level when writing to a tag similar to <code>setReadPower</code> so it can be boosted up to the same values as read power.</p> <pre><code>nano.setWritePower(500); //5.00 dBm. Higher values may cause USB port to brown out\n//Max Write TX Power is 27.00 dBm and may cause temperature-limit throttling\n</code></pre>"},{"location":"print_view/#examples-4-5-readwrite-user-data","title":"Examples 4 &amp; 5 - Read/Write User Data","text":"<p>Example 4 shows how to detect and read a tag's available user memory. Not all UHF RFID tags have user memory and may not be configurable.</p> Example 4 - Read User Data <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Read the user writeable data from a detected tag\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while (!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Press a key to read user data\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  //Read the data from the tag\n  byte responseType;\n  byte myData[64];\n  byte myDataLength = sizeof(myData); //Tell readUserData to read up to 64 bytes\n\n  responseType = rfidModule.readUserData(myData, myDataLength); //readUserData will modify myDataLength to the actual # of bytes read\n\n  if (responseType == RESPONSE_SUCCESS)\n  {\n    //Print User Data\n    Serial.print(F(\"Size [\"));\n    Serial.print(myDataLength);\n    Serial.print(F(\"] User data[\"));\n    for (byte x = 0 ; x &lt; myDataLength ; x++)\n    {\n      if (myData[x] &lt; 0x10) Serial.print(F(\"0\"));\n      Serial.print(myData[x], HEX);\n      Serial.print(F(\" \"));\n    }\n    Serial.println(F(\"]\"));\n  }\n  else\n    Serial.println(F(\"Error reading tag data\"));\n\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p>Example 5 demonstrates how to edit a tag's user data through the <code>.writeUserData()</code> function. This function lets you pass an array of characters to the function and records it to the first tag detected by the reader. </p> Example 5 - Write User Data <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Write new data to the user data area\n  Some tags have 64, 16 4, or 0 bytes of user data available for writing.\n\n  If you write more bytes than is available (10 bytes and only 4 available) module will simply timeout.\n\n  EPC is good for things like UPC (this is a gallon of milk)\n  User data is a good place to write things like the milk's best by date\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while (!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may caues USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n  rfidModule.setWritePower(900); //9.00 dBm. Higher values may caues USB port to brown out\n  //Max Write TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println();\n  Serial.println(F(\"Get all tags out of the area. Press a key to write DATA to first detected tag.\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  //\"Hello\" is recorded as \"Hell\". You can only write even number of bytes\n  uint8_t testData[] = \"ACBD\"; //You can only write even number of bytes\n  byte responseType = rfidModule.writeUserData(testData, sizeof(testData) - 1); //The -1 shaves off the \\0 found at the end of string\n\n  if (responseType == RESPONSE_SUCCESS)\n    Serial.println(\"New Data Written!\");\n  else\n  {\n    Serial.println();\n    Serial.println(\"Failed write\");\n    Serial.println(\"Did you write more data than the tag has memory?\");\n    Serial.println(\"Is the tag locked?\");\n  }\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <pre><code>char testData[] = \"ACBD\"; //Must be even number of bytes. \"Hello\" is recorded as \"Hell\".\nbyte responseType = nano.writeUserData(testData, sizeof(testData) - 1); //The -1 shaves off the \\0 found at the end of string\n</code></pre> <p></p> <p>A few bytes of editable memory may not sound like a lot be remember these are passive tags - no batteries required! You can query a tag for the user's dietary restrictions. Or you could adjust the lighting depending on who walked in the room. Or you could set the time at which a medication must be taken. Perhaps a prosthetic leg goes into a more aggressive mode when basketball shorts are worn. </p>"},{"location":"print_view/#examples-6-7-8-passwords","title":"Examples 6, 7, 8 - Passwords","text":"<p>The next three examples all deal with passwords to lock a tag with an Access Password or disable a tag with a Kill Password. </p> <p>Example 6 - Read Passwords displays the Access and Kill passwords for a tag detected by the reader. The Access password allows a user to lock a tag, preventing modification of various parts of the memory (EPC, User, etc). The Kill password is needed to disable a tag. Both passwords are <code>0x00000000</code> by default. </p> Example 6 - Read Passwords <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Don't get too excited, this only reads the passwords if they are unlocked.\n\n  There are two passwords associated with any given tag: the Kill PW and the Acess PW\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while (!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while (1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Get all tags out of the area. Press a key to read PWs from first detected tag.\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  byte response;\n  byte myPW[4];\n  byte pwLength = sizeof(myPW);\n\n  //Read Kill password\n  response = rfidModule.readKillPW(myPW, pwLength);\n  if (response == RESPONSE_SUCCESS)\n  {\n    Serial.println(\"PW read!\");\n    Serial.print(\"KillPW: [\");\n    for(byte x = 0 ; x &lt; pwLength ; x++)\n    {\n      if(myPW[x] &lt; 0x10) Serial.print(\"0\");\n      Serial.print(myPW[x], HEX);\n      Serial.print(\" \");\n    }\n    Serial.println(\"]\");\n  }\n  else\n    Serial.println(\"Failed read\");\n\n\n  //Read Access PW\n  pwLength = sizeof(myPW); //Reset this variable. May have been changed above.\n  response = rfidModule.readAccessPW(myPW, pwLength);\n  if (response == RESPONSE_SUCCESS)\n  {\n    Serial.println(\"PW read!\");\n    Serial.print(\"AccessPW: [\");\n    for(byte x = 0 ; x &lt; pwLength ; x++)\n    {\n      if(myPW[x] &lt; 0x10) Serial.print(\"0\");\n      Serial.print(myPW[x], HEX);\n      Serial.print(\" \");\n    }\n    Serial.println(\"]\");\n  }\n  else\n    Serial.println(\"Failed read\");\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p></p> <p>Example 7 - Write Passwords shows you how to write new passwords for both Access and Kill. </p> Example 7 - Write Passwords <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  Obviously, be careful because this premanently and irrevocably destroys a tag.\n\n  This shows how to send the right command (with password) to disable a tag.\n\n  Arduino pin 2 to Nano TX\n  Arduino pin 3 to Nano RX\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while(!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while(1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n  rfidModule.setWritePower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Write TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Get all tags out of the area. Press a key to write PWs to first detected tag.\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  byte myKillPW[] = {0xEE, 0xFF, 0x11, 0x22};\n  byte response = rfidModule.writeKillPW(myKillPW, sizeof(myKillPW));\n\n  if (response == RESPONSE_SUCCESS)\n    Serial.println(\"New Kill PW Written!\");\n  else\n    Serial.println(\"Failed write\");\n\n  byte myAccessPW[] = {0x12, 0x34, 0x56, 0x78};\n  response = rfidModule.writeAccessPW(myAccessPW, sizeof(myAccessPW));\n\n  if (response == RESPONSE_SUCCESS)\n    Serial.println(\"New Access PW Written!\");\n  else\n    Serial.println(\"Failed write\");\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p>These values can be adjusted from the passwords set in the example by changing the following lines for myKillPW and myAccessPW:</p> <pre><code>byte myKillPW[] = {0xEE, 0xFF, 0x11, 0x22};\n\nbyte myAccessPW[] = {0x12, 0x34, 0x56, 0x78};\n</code></pre> <p></p> <p>After running Example 7, re-run Example 6 to see the updated passwords and ensure they are correct. It may seem odd that you can view the passwords. The Gen2 protocol has quite a few methods to lock out various portions of the memory preventing them from being read. Once the Access password is set the ability to read passwords, read user memory, and read portions of the EPC can all be controlled; this is called locking. Currently, locking is not supported in the Arduino library but it is available in the URA and in the Mercury API.</p> <p>Example 8 - Kill Tag is an interesting example. It's pretty rare that you'll need to kill a tag but we find the concept fascinating and wanted to build in support for it.</p> Danger! <p>Note: Killing a tag blows an internal fuse to the IC and makes the tag irreversibly dead.</p> Example 8 - Kill Tag <pre><code>/*\n  Reading multiple RFID tags, simultaneously!\n  By: Nathan Seidle @ SparkFun Electronics\n  Date: October 3rd, 2016\n  https://github.com/sparkfun/Simultaneous_RFID_Tag_Reader\n\n  To kill a tag the tag's kill password must be set. When tags are shipped their passwords\n  are set to 0x00000000. See the Write_Passwords example to write access and kill passwords.\n\n  Obviously, be careful because this premanently and irrevocably destroys a tag.\n\n  This shows how to send the right command (with password) to disable a tag.\n*/\n\n// Library for controlling the RFID module\n#include \"SparkFun_UHF_RFID_Reader.h\"\n\n// Create instance of the RFID module\nRFID rfidModule;\n\n// By default, this example assumes software serial. If your platform does not\n// support software serial, you can use hardware serial by commenting out these\n// lines and changing the rfidSerial definition below\n#include &lt;SoftwareSerial.h&gt;\nSoftwareSerial softSerial(2, 3); //RX, TX\n\n// Here you can specify which serial port the RFID module is connected to. This\n// will be different on most platforms, so check what is needed for yours and\n// adjust the definition as needed. Some examples are provided below\n#define rfidSerial softSerial // Software serial (eg. Arudino Uno or SparkFun RedBoard)\n// #define rfidSerial Serial1 // Hardware serial (eg. ESP32 or Teensy)\n\n// Here you can select the baud rate for the module. 38400 is recommended if\n// using software serial, and 115200 if using hardware serial.\n#define rfidBaud 38400\n// #define rfidBaud 115200\n\n// Here you can select which module you are using. This library was originally\n// written for the M6E Nano only, and that is the default if the module is not\n// specified. Support for the M7E Hecto has since been added, which can be\n// selected below\n#define moduleType ThingMagic_M6E_NANO\n// #define moduleType ThingMagic_M7E_HECTO\n\nvoid setup()\n{\n  Serial.begin(115200);\n\n  while(!Serial);\n  Serial.println();\n  Serial.println(\"Initializing...\");\n\n  if (setupRfidModule(rfidBaud) == false)\n  {\n    Serial.println(\"Module failed to respond. Please check wiring.\");\n    while(1); //Freeze!\n  }\n\n  rfidModule.setRegion(REGION_NORTHAMERICA); //Set to North America\n\n  rfidModule.setReadPower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Read TX Power is 27.00 dBm and may cause temperature-limit throttling\n\n  rfidModule.setWritePower(500); //5.00 dBm. Higher values may cause USB port to brown out\n  //Max Write TX Power is 27.00 dBm and may cause temperature-limit throttling\n}\n\nvoid loop()\n{\n  Serial.println(F(\"Get all tags out of the area. Press a key to KILL first detected tag.\"));\n  while (!Serial.available()); //Wait for user to send a character\n  Serial.read(); //Throw away the user's character\n\n  byte myKillPW[] = {0x1A, 0x2B, 0x3C, 0x4E}; //This must be edited to match your kill password\n//  byte myKillPW[] = {0xEE, 0xFF, 0x11, 0x22};\n\n  byte response = rfidModule.killTag(myKillPW, sizeof(myKillPW));\n\n  if (response == RESPONSE_SUCCESS)\n    Serial.println(\"Tag has been killed!\");\n  else\n  {\n    Serial.println(\"Kill Failed\");\n    Serial.println(\"Did you set the kill PW to something other than 0s?\");\n  }\n}\n\n//Gracefully handles a reader that is already configured and already reading continuously\n//Because Stream does not have a .begin() we have to do this outside the library\nboolean setupRfidModule(long baudRate)\n{\n  rfidModule.begin(rfidSerial, moduleType); //Tell the library to communicate over serial port\n\n  //Test to see if we are already connected to a module\n  //This would be the case if the Arduino has been reprogrammed and the module has stayed powered\n  rfidSerial.begin(baudRate); //For this test, assume module is already at our desired baud rate\n  delay(100); //Wait for port to open\n\n  //About 200ms from power on the module will send its firmware version at 115200. We need to ignore this.\n  while (rfidSerial.available())\n    rfidSerial.read();\n\n  rfidModule.getVersion();\n\n  if (rfidModule.msg[0] == ERROR_WRONG_OPCODE_RESPONSE)\n  {\n    //This happens if the baud rate is correct but the module is doing a ccontinuous read\n    rfidModule.stopReading();\n\n    Serial.println(F(\"Module continuously reading. Asking it to stop...\"));\n\n    delay(1500);\n  }\n  else\n  {\n    //The module did not respond so assume it's just been powered on and communicating at 115200bps\n    rfidSerial.begin(115200); //Start serial at 115200\n\n    rfidModule.setBaud(baudRate); //Tell the module to go to the chosen baud rate. Ignore the response msg\n\n    rfidSerial.begin(baudRate); //Start the serial port, this time at user's chosen baud rate\n\n    delay(250);\n  }\n\n  //Test the connection\n  rfidModule.getVersion();\n  if (rfidModule.msg[0] != ALL_GOOD)\n    return false; //Something is not right\n\n  //The module has these settings no matter what\n  rfidModule.setTagProtocol(); //Set protocol to GEN2\n\n  rfidModule.setAntennaPort(); //Set TX/RX antenna ports to 1\n\n  return true; //We are ready to rock\n}\n</code></pre> <p>It is very good to see that the protocol has the kill feature. Killing a tag makes sense after an item has been purchased (gallon of milk) or a process has been completed (dry cleaning has been picked up). By limiting the life-span of a tag you can help protect end user privacy and tracking.</p> <p>The Gen2 protocol is well written and prevents a user from walking into a Wal-Mart and blasting away all the tags that haven't been configured. The default Kill password is all 0s but any tag will ignore the kill command with the password set to 0s. Therefore, you must first write a non-zero kill password (using Example7) then you must issue the kill command using the new password.</p> <p></p> <p>If you're very paranoid about someone else using an UHF RFID reader/writer to reconfigure your tags consider writing new Access and Kill passwords to your tags then use the Universal Reader Assistant to lock the tags.</p>"},{"location":"print_view/#troubleshooting","title":"Troubleshooting","text":""},{"location":"print_view/#power-supply","title":"Power Supply","text":"<p>Make sure your selected power supply can source enough current to power the Simultaneous RFID Reader - M7E to avoid brown outs as the board can draw over 720mA @5V when read power is maxed out. Refer to page 29, \"DC Power Requirements\" of the M7E Hecto Design Guide for a detailed chart of current draw at various input voltages and read power levels.</p>"},{"location":"print_view/#thermal-throttling_1","title":"Thermal Throttling","text":"<p>The M7E has built-in thermal protection that will throttle itself to prevent permanent damage from heat. This board has a thermal pad to help dissipate heat for some applications but if you plan to run the M7E at high read powers for extended periods of time (1hr +), we recommend attaching an external heat sink to the thermal pad.</p> <p>You can also use the module's ability to change read duty cycle to reduce the heat dissipation as well. Check out the M7E Hecto Design Guide for more information.</p>"},{"location":"print_view/#logic-levels","title":"Logic Levels","text":"<p>Reminder, the Simultaneous RFID Reader M7E 3.3V operates at 3.3V logic. Make sure any devices (development board or serial converter) connected to the serial interface operate at 3.3V logic or are properly shifted to avoid damaging the M7E Hecto.</p>"},{"location":"print_view/#range-discrepancies","title":"Range Discrepancies","text":"<p>The functional range of the Simultaneous RFID Reader - M7E depends on a wide variety of factors and any one of these can increase or decrease the range at which tags are read. Make sure the antenna (either PCB or external) is free of anything that may cause interference. For example, the PCB antenna's range can drastically change depending on whether it is in open space or next to a solid object (such as a desk or person). Similarly, a tag's position in relation to the antenna as well as any solid objects (again, think person or other object) it may be near or placed on can significantly change the range.</p> <p>For ideal range, make sure both the antenna and tag are in as much open space as possible and positioned in line with the antenna's radiation pattern. </p>"},{"location":"print_view/#general-troubleshooting-and-technical-assistance","title":"General Troubleshooting and Technical Assistance","text":"<p>If you need technical assistance and more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting.</p> <p> SparkFun Technical Assistance Page </p> <p>If you don't find what you need there, the SparkFun Forums are a great place to find and ask for help. If this is your first visit, you'll need to create a Forum Account to search product forums and post questions.</p> <p> Create New Forum Account </p> <p> Log Into SparkFun Forums </p>"},{"location":"print_view/#resources","title":"Resources","text":"<p>For more information about the SparkFun Simultaneous RFID Reader - M7E Hecto, check out the following resources:</p> <ul> <li>Schematic</li> <li>Eagle Files</li> <li>Board Dimensions</li> <li>M7E Hecto User Guide</li> <li>GitHub Hardware Repo</li> <li>SparkFun Simultaneous RFID Reader Arduino Library</li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>For more information about the SparkFun Simultaneous RFID Reader - M7E Hecto, check out the following resources:</p> <ul> <li>Schematic</li> <li>Eagle Files</li> <li>Board Dimensions</li> <li>M7E Hecto User Guide</li> <li>GitHub Hardware Repo</li> <li>SparkFun Simultaneous RFID Reader Arduino Library</li> </ul>"},{"location":"software_setup/","title":"Library Setup","text":"<p>Attention</p> <p>If this is your first time using Arduino, please read through our tutorial on installing the Arduino IDE. If you have not installed an Arduino library before, we recommend you check out our installation guide.</p> <p>The SparkFun Simultaneous RFID Tag Reader Arduino library, while originally written for the M6E-NANO, works just as well for the M7E-HECTO on this RFID Reader breakout. The library handles all serial communication, byte manipulations, and CRC verifications making it easy to quickly get started using the board. Users can download and install the library through the Arduino Library Manager by searching for \"SparkFun Simultaneous RFID\" and selecting the latest version. If you prefer to manually install the library, download a ZIP of it by clicking the button below:</p> <p> SparkFun Simultaneous RFID Tag Reader Arduino Library (ZIP) </p> <p>With the library installed, let's take a closer look at some of the examples included in it. You can take a look at them by navigating to File &gt; Examples &gt; SparkFun Simultaneous RFID Tag Reader Library &gt; Examples.</p>"},{"location":"thermal_management/","title":"Thermal Management Considerations","text":"<p>The module can reach temperatures greater than 85\u00b0C (185\u00b0F) when operating at full read power over extended periods so thermal management is an important consideration using this board. </p> <p>The module will automatically throttle itself to prevent permanent damage from heat. This board provides enough ground plane heatsinking to allow the module to operate at full read power for tens of minutes before throttling occurs. If you plan to operate the module at full power for extended periods (over an hour) we recommend attaching a heatsink. </p> <p>You can get the 1:1 dimensional drawing of the board here. The dimensional drawing below shows the exposed thermal pad and mounting holes. </p> <p></p> Dimensional Drawing showing the mounting holes and exposed thermal pad <p>Heatsinking won\u2019t be required in most prototyping applications. However, if you have heat-sensitive items near the module (such as temperature or humidity sensors) they may be influenced by the module. If you are planning to install the module for long-term operation we recommend attaching a heatsink with thermal compound for best results.</p> <p>The module also supports changing the read duty cycle to reduce heat dissipation as well. Refer to the M7E-Hecto Design Guide for more information.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":""},{"location":"troubleshooting/#power-supply","title":"Power Supply","text":"<p>Make sure your selected power supply can source enough current to power the Simultaneous RFID Reader - M7E to avoid brown outs as the board can draw over 720mA @5V when read power is maxed out. Refer to page 29, \"DC Power Requirements\" of the M7E Hecto Design Guide for a detailed chart of current draw at various input voltages and read power levels.</p>"},{"location":"troubleshooting/#thermal-throttling","title":"Thermal Throttling","text":"<p>The M7E has built-in thermal protection that will throttle itself to prevent permanent damage from heat. This board has a thermal pad to help dissipate heat for some applications but if you plan to run the M7E at high read powers for extended periods of time (1hr +), we recommend attaching an external heat sink to the thermal pad.</p> <p>You can also use the module's ability to change read duty cycle to reduce the heat dissipation as well. Check out the M7E Hecto Design Guide for more information.</p>"},{"location":"troubleshooting/#logic-levels","title":"Logic Levels","text":"<p>Reminder, the Simultaneous RFID Reader M7E 3.3V operates at 3.3V logic. Make sure any devices (development board or serial converter) connected to the serial interface operate at 3.3V logic or are properly shifted to avoid damaging the M7E Hecto.</p>"},{"location":"troubleshooting/#range-discrepancies","title":"Range Discrepancies","text":"<p>The functional range of the Simultaneous RFID Reader - M7E depends on a wide variety of factors and any one of these can increase or decrease the range at which tags are read. Make sure the antenna (either PCB or external) is free of anything that may cause interference. For example, the PCB antenna's range can drastically change depending on whether it is in open space or next to a solid object (such as a desk or person). Similarly, a tag's position in relation to the antenna as well as any solid objects (again, think person or other object) it may be near or placed on can significantly change the range.</p> <p>For ideal range, make sure both the antenna and tag are in as much open space as possible and positioned in line with the antenna's radiation pattern. </p>"},{"location":"troubleshooting/#general-troubleshooting-and-technical-assistance","title":"General Troubleshooting and Technical Assistance","text":"<p>If you need technical assistance and more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting.</p> <p> SparkFun Technical Assistance Page </p> <p>If you don't find what you need there, the SparkFun Forums are a great place to find and ask for help. If this is your first visit, you'll need to create a Forum Account to search product forums and post questions.</p> <p> Create New Forum Account </p> <p> Log Into SparkFun Forums </p>"},{"location":"universal_assistant/","title":"Using the Universal Reader Assistant","text":"<p>The Universal Reader Assistant is a great way to start taking advantage of the full capabilities of the M7E-Hecto. Unfortunately, it's only available for Windows.</p>"},{"location":"universal_assistant/#download-install","title":"Download &amp; Install","text":"<p>Start by downloading the Universal Reader Assistant (URA). 32-bit and 64-bit versions are available.</p> <p> Universal Reader Assistant Download </p> <p>Open the installer once downloading finishes and follow the installation wizard instructions.</p>"},{"location":"universal_assistant/#universal-reader-assistant-setup-wizard","title":"Universal Reader Assistant Setup Wizard","text":"<p>Make sure the Simultaneous RFID Reader is plugged in either over USB or through the Serial Header to a USB-to-Serial converter with the UART selection switch in the correct position, and open the Universal Reader Assistant. You should be greeted by the Connection Wizard menu to select the reader type and port:</p> <p></p> <p>You can skip this selection and move on to the main menu of the Universal Reader Assistant. Otherwise, select the port your Simultaneous RFID Reader is on and click \"Next\" and the Connection Wizard should show you the RFID reader settings:</p> <p></p> <p>Click either \"Connect &amp; Read\" or \"Connect\" to open up the Universal Reader Assistant main window.</p>"},{"location":"universal_assistant/#universal-reader-assistant-main-window","title":"Universal Reader Assistant Main Window","text":"<p>The main window of the Universal Reader Assistant contains a whole bunch of settings and status menus to adjust everything from the M7E's read/write options, power level and even perform firmware updates. It also has a handy readout for the M7E's internal temperature along with multiple tabs for interacting with tags the M7E sees including simple tag data, writing to the user memory and also locking a tag with a custom password.</p> <p>There are a ton of features to the M7E from ThingMagic. Poke around the Universal Reader Assistant to learn more. Write EPC and User Memory are two of the most commonly used tabs.</p> <p>Info</p> <p>Note: The \u2018Transport Logging\u2019 checkbox is very handy. Select this box and all the serial communication will be recorded to a log file. These HEX bytes can be deciphered and recreated using an Arduino or other microcontroller if you need a particular capability or feature that is not supported in the SparkFun Simultaneous RFID Reader Arduino library.</p>"},{"location":"universal_assistant/#thermal-throttling","title":"Thermal Throttling","text":"<p>If you see this window pop up it means the module is reporting a temperature-limit fault condition. The module has an internal temperature sensor and will protect itself from permanent damage. You\u2019ll need to lower your read power or add heatsinking. See the previous section of this guide, Thermal Considerations, for more information.</p>"},{"location":"github/","title":"github directory","text":"<p>This folder should contain the instructions for submitting issues and pull requests for this project</p>"},{"location":"github/contribute/","title":"Contribute: Make an Augmentation!","text":"<p>Spot an improvement opportunity? Feel free to contribute to our open-source design and documentation. </p>"},{"location":"github/contribute/#improve-our-documentation","title":"Improve our Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>These pages are contained in the <code>docs</code> folder of the SparkFun Simultaneous RFID Reader - M7E repository.</li> </ul>"},{"location":"github/contribute/#submit-a-correction","title":"Submit a Correction","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your corrections or improvements to the markdown file.</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvements to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/contribute/#improve-our-hardware-design","title":"Improve our Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun Simultaneous RFID Reader - M7E repository.</li> </ul>"},{"location":"github/contribute/#submit-a-design-enhancement","title":"Submit a Design Enhancement","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ol>"},{"location":"github/contribute/#contributors","title":"Contributors","text":"<p>Let's provide some recognition to the contributors for this project!</p> <p> </p>"},{"location":"github/file_issue/","title":"Did we make a mistake?","text":"<p>Spot something wrong? Please let us know. </p> <p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. This Submit Issues page is not where users should seek assistance.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search the product forums and ask questions.</p> <p>Account Registration Required</p> <p>For your first visit to our forum, you'll need to create a Forum Account to post questions.</p>"},{"location":"github/file_issue/#discrepancies-in-the-documentation","title":"Discrepancies in the Documentation","text":"<p>All of our documentation can be modified by you! Please help us make it better.</p> <ul> <li>The documentation files for these pages are contained in the <code>docs</code> folder of the SparkFun Simultaneous RFID Reader - M7E repository.</li> </ul>"},{"location":"github/file_issue/#spot-something-wrong","title":"\ud83d\udd0d Spot something wrong?","text":"<p>If a section of the documentation is incorrect, please open an issue and let us know.</p>"},{"location":"github/file_issue/#do-you-have-a-suggested-correction","title":"Do you have a suggested correction?","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your correction(s) or improvement(s) to the markdown file(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvement(s) to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/file_issue/#problems-in-the-hardware-design","title":"Problems in the Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun Simultaneous RFID Reader - M7E repository.</li> </ul>"},{"location":"github/file_issue/#does-something-not-make-sense","title":"Does something not make sense? \ud83e\udd14","text":"<p>If part of the design is confusing, please open an issue and let us know.</p>"},{"location":"github/file_issue/#did-we-forget-to-include-an-important-function-of-the-board","title":"Did we forget to include an important function of the board? \ud83e\udd26","text":"<p>If part of the board's functionality is missing, please open an issue and file a feature request.</p> <p>Design Considerations</p> <p>Please keep in mind that we may intentionally exclude certain functions of the board to meet our product design requirements.</p> <ul> <li>For example, our Qwiic Micro boards are intended to fit on a small board layout and only use I<sup>2</sup>C communication; therefore, we may not have the SPI and interrupt pins available for users.</li> </ul>"},{"location":"github/file_issue/#do-you-wish-to-contribute-directly-to-improving-the-board-design","title":"Do you wish to contribute directly to improving the board design?","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ol>"}]}